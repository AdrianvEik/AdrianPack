Index: AdrianPack/Aplot.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import types\r\n\r\nimport numpy.random\r\nimport scipy.stats\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\nfrom scipy.optimize import curve_fit\r\nfrom typing import Sized, Iterable, Union, Optional, Any, Type, Tuple, List, \\\r\n    Dict, Callable\r\n\r\ntry:\r\n    from TN_code.plotten.TISTNplot import TNFormatter\r\nexcept ImportError:\r\n    try:\r\n        from .TN_code.plotten.TISTNplot import TNFormatter\r\n    except ImportError:\r\n        TNFormatter = False\r\n\r\ntry:\r\n    from Helper import test_inp\r\nexcept ImportError:\r\n    from .Helper import test_inp\r\n\r\n# TODO: plot straight from files\r\n# TODO: plot normal distrubtion over histogram\r\n# TODO: plot bodeplots (maybe?)\r\n\r\n# TODO: Recheck all examples and upload to git with an example.py file\r\n# TODO: restructure to use base class from which to inherit standardized methods\r\n\r\nclass Base:\r\n    \"\"\"\r\n    Base class of Aplot object\r\n    \"\"\"\r\n    def __init__(self, *args, **kwargs):\r\n        \"\"\"\"\r\n        :param: x\r\n            ObjectType -> numpy.ndarry\r\n            Array with values that correspond to the input values or control\r\n             values.\r\n        :param: y\r\n            ObjectType -> numpy.ndarry\r\n            Array with values that correspond to the output values f(x) or\r\n             response values.\r\n        \"\"\"\r\n\r\n        self.decimal_comma = True\r\n        self.TNFormatter = TNFormatter\r\n        if 'decimal_comma' in kwargs:\r\n            test_inp(kwargs[\"decimal_comma\"], bool, \"decimal_comma\")\r\n            self.decimal_comma = kwargs['decimal_comma']\r\n            # If the decimal comma is set to False the TNformatter should\r\n            # if available be deactivated.\r\n            if not self.decimal_comma:\r\n                self.TNFormatter = self.decimal_comma\r\n\r\n        add_mode = False\r\n        if \"add_mode\" in kwargs:\r\n            add_mode = kwargs[\"add_mode\"]\r\n            test_inp(add_mode, bool, \"add_mode\")\r\n\r\n        if not add_mode:\r\n            self.fig, self.ax = plt.subplots()\r\n\r\n        self.response_var = \"y\"\r\n        if \"response_var\" in kwargs:\r\n            self.response_var = kwargs[\"response_var\"]\r\n            test_inp(self.response_var, str, \"response variable\")\r\n\r\n        self.control_var = \"x\"\r\n        if \"control_var\" in kwargs:\r\n            self.control_var = kwargs[\"control_var\"]\r\n            test_inp(self.control_var, str, \"control variable\")\r\n\r\n        self.label = \"Data\"\r\n        if \"data_label\" in kwargs:\r\n            test_inp(kwargs[\"data_label\"], str, \"data label\")\r\n            self.label = kwargs[\"data_label\"]\r\n\r\n        if \"x_lim\" in kwargs:\r\n            self.x_lim = kwargs[\"x_lim\"]\r\n            test_inp(self.x_lim, (list, tuple, np.ndarray), \"x lim\")\r\n\r\n            try:\r\n                assert len(self.x_lim) == 2\r\n            except AssertionError:\r\n                raise IndexError(\r\n                    \"Xlim should only contain xmin and xmax but the\"\r\n                    \"length of xlim does not equal 2.\")\r\n\r\n            test_inp(self.x_lim[0], (float, int), \"xmin\")\r\n            test_inp(self.x_lim[1], (float, int), \"xmax\")\r\n\r\n        if \"y_lim\" in kwargs:\r\n            self.y_lim = kwargs[\"y_lim\"]\r\n            test_inp(self.y_lim, (list, tuple, np.ndarray), \"x lim\")\r\n\r\n            try:\r\n                assert len(self.y_lim) == 2\r\n            except AssertionError:\r\n                raise IndexError(\r\n                    \"Ylim should only contain ymin and ymax but the\"\r\n                    \"length of ylim does not equal 2.\")\r\n\r\n            test_inp(self.y_lim[0], (float, int), \"ymin\")\r\n            test_inp(self.y_lim[1], (float, int), \"ymax\")\r\n\r\n        # Read x and y values\r\n        self.file_format = kwargs[\"file_format\"] if \"file_format\" in kwargs else [\"x\", \"y\", \"x_err\", \"y_err\"]\r\n        test_inp(self.file_format, list, \"File format\")\r\n\r\n        if len(args) >= 2 and args[1] is not None:\r\n            self.x = args[0]\r\n            self.y = args[1]\r\n        elif len(args) == 1 or args[1] is None:\r\n            self.x = args[0]\r\n            self.y = None\r\n        elif \"file\" in kwargs:\r\n            self.x = kwargs[\"file\"]\r\n\r\n        if self.x.__class__.__name__ in [\"ndarray\", \"list\", \"tuple\"]:\r\n            # either matrix or normal x and y\r\n            self.x = np.asarray(self.x, dtype=np.float32)\r\n            if self.y is not None:\r\n                self.y = np.asarray(self.y, dtype=np.float32)\r\n            # 1 Dimensional array\r\n            if self.x.ndim == 1:\r\n                if self.y is None:\r\n                    self.y = self.x\r\n                    self.x = range(len(self.x))\r\n\r\n            # Matrix\r\n            else:\r\n                self.array_parse(self.x)\r\n\r\n        # File\r\n        elif self.x.__class__.__name__ == \"str\" or self.x.__class__.__name__ == \"Fileread\":\r\n            # File\r\n            try:\r\n                from .Fileread import Fileread\r\n            except ImportError:\r\n                try:\r\n                    from AdrianPack.Fileread import Fileread\r\n                except ImportError:\r\n                    raise ImportError(\"Fileread not available for use, include\"\r\n                                      \" Fileread in the script folder to read files.\")\r\n\r\n            # If the type is a string turn it in to a Fileread object else use\r\n            # the Fileread object\r\n            data_obj = Fileread(path=self.x, **kwargs) if type(self.x) is str else self.x\r\n            data = data_obj()\r\n\r\n            for key in data.keys():\r\n                if key in \"x\":\r\n                    self.x = data[key]\r\n                if key in \"y\":\r\n                    self.y = data[key]\r\n                if key in \"x_err\":\r\n                    self.x_err = data[key]\r\n                if key in \"y_err\":\r\n                    self.y_err = data[key]\r\n\r\n            if type(self.x) in [None, str] or self.y is None:\r\n                data_obj.output = \"numpy\"\r\n                self.array_parse(data_obj())\r\n\r\n        self.kwargs = kwargs\r\n\r\n    def array_parse(self, data):\r\n        self.x = data[:, self.file_format.index(\"x\")]\r\n        self.y = data[:, self.file_format.index(\"y\")]\r\n\r\n        if data.shape[1] == 3:\r\n            if \"x_err\" in self.file_format:\r\n                self.x_err = data[:, self.file_format.index(\"x_err\")]\r\n            else:\r\n                self.y_err = data[:, self.file_format.index(\"y_err\")]\r\n        elif data.shape[1] > 4:\r\n            self.x_err = data[:, self.file_format.index(\"x_err\")]\r\n            self.y_err = data[:, self.file_format.index(\"y_err\")]\r\n        return None\r\n\r\n    def single_form(self, x_label: str, y_label: str, grid: bool = True,\r\n                    **kwargs) \\\r\n            -> Union[Tuple[plt.figure, plt.axes], None]:\r\n        \"\"\"\"\r\n        Format a figure with 1 x-axis and y-axis.\r\n\r\n        REQUIRED:\r\n        :param: x_label\r\n            ObjectType -> str\r\n            Label placed on the x-axis, usually uses input from __init__ kwargs\r\n        :param: y_label\r\n            ObjectType -> str\r\n            Label placed on the y-axis, usually uses input from __init__ kwargs\r\n\r\n        OPTIONAL:\r\n        :param: grid\r\n            ObjectType -> bool\r\n            True to show grid and False to turn the grid off, default True.\r\n            Takes input from __innit__ kwargs.\r\n\r\n        KWARGS:\r\n        :param: fig_ax\r\n            ObjectType -> Tuple\r\n            The tuple should contain an fig, ax pair with fig and ax being\r\n                fig:\r\n                ObjectType -> matplotlib.pyplot.fig object\r\n                Use this input to apply formatting on input fig\r\n                ax:\r\n                ObjectType -> matplotlib.pyplot.Axes.ax object\r\n                Use this input to apply formatting on input ax\r\n\r\n            EXAMPLE\r\n                single_form(\"x_label\", \"y_label\", fig_ax=(plt.subplots()))\r\n\r\n        :param: x_lim\r\n            ObjectType -> Union[Tuple, List, np.ndarray]\r\n            The limits of the horizontal axes, contains a xmin (xlim[0]) and\r\n            xmax (xlim[1]) pair. Both xmin and xmax should be of type\r\n            float, int or numpy float.\r\n\r\n            EXAMPLE\r\n                single_form(\"x_label\", \"y_label\", xlim=[0, 2.4])\r\n\r\n        :param: y_lim\r\n            ObjectType -> Union[Tuple, List, np.ndarray]\r\n            The limits of the vertical axes, contains a ymin (ylim[0]) and\r\n            ymax (ylim[1]) pair. Both ymin and ymax should be of type\r\n            float, int or numpy float.\r\n\r\n            EXAMPLE\r\n                single_form(\"x_label\", \"y_label\", ylim=[-15.4, 6.9])\r\n\r\n         :returns:\r\n            ObjectType -> Union[Tuple[matplotlib.pyplot.fig, matplotlib.pyplot.Axes.ax], NoneType]\r\n            When fig_ax input is part of the input this function will return\r\n            the fig, ax pair\r\n            if not the return is of type NoneType\r\n\r\n        EXAMPLE:\r\n            # Initiate a fig, ax pair\r\n            fig, ax = plt.subplots()\r\n            # Plot the data\r\n            ax.plot(x_data, y_data)\r\n            # format the plot\r\n            Aplot().single_form(\"x_label\", \"y_label\", (fig, ax))\r\n            # Show the formatted plot\r\n            plt.show()\r\n\r\n            #TODO: Add example with Aplot object\r\n\r\n        NOTES ON PARAMS  x_label, y_label and grid:\r\n            Direct input in this function will overwrite __innit__ inputs.\r\n        \"\"\"\r\n\r\n        if \"fig_ax\" in kwargs:\r\n            # TODO: test these tests and test the usability of the object\r\n            test_inp(kwargs[\"fig_ax\"], (tuple, list), \"fig ax pair\")\r\n            test_inp(kwargs[\"fig_ax\"][0], plt.Figure, \"fig\")\r\n            test_inp(kwargs[\"fig_ax\"][1], plt.Axes, \"ax\")\r\n\r\n            self.fig = kwargs[\"fig_ax\"][0]\r\n            self.ax = kwargs[\"fig_ax\"][1]\r\n\r\n        if \"x_lim\" in self.kwargs:\r\n            self.ax.set_xlim(self.x_lim)\r\n        elif \"x_lim\" in kwargs:\r\n            x_lim = kwargs[\"x_lim\"]\r\n\r\n            test_inp(x_lim, (list, tuple, np.ndarray), \"x lim\")\r\n\r\n            try:\r\n                assert len(x_lim) == 2\r\n            except AssertionError:\r\n                raise IndexError(\r\n                    \"Xlim should only contain xmin and xmax but the\"\r\n                    \"length of xlim does not equal 2.\")\r\n\r\n            test_inp(x_lim[0], (float, int), \"xmin\")\r\n            test_inp(x_lim[1], (float, int), \"xmax\")\r\n\r\n            self.ax.set_xlim(x_lim)\r\n\r\n        if \"y_lim\" in self.kwargs:\r\n            self.ax.set_ylim(self.y_lim)\r\n        elif \"y_lim\" in kwargs:\r\n            y_lim = kwargs[\"y_lim\"]\r\n\r\n            test_inp(y_lim, (list, tuple, np.ndarray), \"y lim\")\r\n\r\n            try:\r\n                assert len(y_lim) == 2\r\n            except AssertionError:\r\n                raise IndexError(\r\n                    \"Ylim should only contain ymin and ymax but the\"\r\n                    \"length of ylim does not equal 2.\")\r\n\r\n            test_inp(y_lim[0], (float, int), \"ymin\")\r\n            test_inp(y_lim[1], (float, int), \"ymax\")\r\n\r\n            self.ax.set_ylim(y_lim)\r\n\r\n        self.ax.set_xlabel(x_label)\r\n        self.ax.set_ylabel(y_label)\r\n\r\n        if self.TNFormatter:\r\n            x_pr = 3\r\n            if \"x_precision\" in self.kwargs:\r\n                test_inp(self.kwargs[\"x_precision\"], int, \"x_precision\",\r\n                         True)\r\n                x_pr = self.kwargs[\"x_precision\"]\r\n            y_pr = 3\r\n            if \"y_precision\" in self.kwargs:\r\n                test_inp(self.kwargs[\"y_precision\"], int, \"y_precision\",\r\n                         True)\r\n                y_pr = self.kwargs[\"y_precision\"]\r\n\r\n            self.ax.xaxis.set_major_formatter(TNFormatter(x_pr))\r\n            self.ax.yaxis.set_major_formatter(TNFormatter(y_pr))\r\n\r\n        if grid:\r\n            plt.grid()\r\n\r\n        if \"legend_loc\" in self.kwargs:\r\n            test_inp(self.kwargs[\"legend_loc\"], str, \"legenc loc\")\r\n            plt.legend(loc=self.kwargs[\"legend_loc\"])\r\n        elif \"legend_loc\" in kwargs:\r\n            test_inp(self.kwargs[\"legend_loc\"], str, \"legenc loc\")\r\n            plt.legend(loc=kwargs[\"legend_loc\"])\r\n        else:\r\n            plt.legend(loc='lower right')\r\n\r\n        plt.tight_layout()\r\n        if \"fig_ax\" in kwargs:\r\n            return self.fig, self.ax\r\n        else:\r\n            return None\r\n\r\n\r\n\r\nclass Default(Base):  # TODO: expand the docstring #TODO x and y in args.\r\n    \"\"\"\"\r\n    Plotting tool to plot files (txt, csv or xlsx), numpy arrays or\r\n    pandas table with fit and error.\r\n\r\n    Input arguments:\r\n        :param: file\r\n            # TODO: add os library based Path object support.\r\n\r\n            ObjectType -> str\r\n            Path to the file in str.\r\n            EXAMPLE:\r\n                plot_obj = Aplot(x, y, )\r\n\r\n        :param: degree\r\n            ObjectType -> int\r\n            N-th degree polynomial that correlates with input data. Currently\r\n            only 1st to 3rd degree polynomials are supported. For higher degree\r\n            polynomials (or any other function) use your own function as input.\r\n            This can be done with the fx and func_format params.\r\n\r\n            Example\r\n                plot_obj = Aplot(x, y, degree=1) # Linear fit\r\n\r\n        :param: save_as\r\n            # TODO: Implement save_as\r\n\r\n        :param: x_err\r\n            ObjectType -> Union[np.ndarray, float, int]\r\n            Array with error values or single error value that is applied\r\n            to all values for x.\r\n\r\n            EXAMPLE\r\n            # For an array of error values\r\n            plot_obj = Aplot(x, y, x_err=x_err)\r\n            plot_obj()\r\n\r\n            # For a single error value\r\n            plot_obj = Aplot(x, y, x_err=0.1)\r\n            plot_obj()\r\n\r\n        :param: y_err\r\n            ObjectType -> Union[np.ndarray, float, int]\r\n            Array with error values or single error value that is applied\r\n            to all values for y.\r\n\r\n        :param: x_label\r\n            ObjectType -> str\r\n            String with label placed on the horizontal axis, can contain\r\n            latex.\r\n\r\n            EXAMPLE\r\n            # To include latex in the label the string (or part that contains\r\n            # latex) should start and end with \"$\"\r\n\r\n            label = r\"$x$-axis with $\\latex$\"\r\n            plot_obj = Aplot(x, y, x_label=label)\r\n            # Show plot\r\n            plot_obj()\r\n\r\n\r\n        :param: y_label\r\n            ObjectType -> str\r\n            String with label placed on the horizontal axis, can contain\r\n            latex.\r\n\r\n        :param: fx\r\n            ObjectType -> function\r\n            The function to fit the data to.\r\n\r\n            Typical fx function example\r\n            def f(x: float, a: float, b: float) -> float:\r\n                '''\r\n                Input\r\n                    x: float\r\n                        Variabale input\r\n                    a: float\r\n                        1st fit paramater\r\n                    b: float\r\n                        2nd fit parameter\r\n                Returns\r\n                    rtype: float\r\n                    Output of function f(x).\r\n                '''\r\n                return a*x + b\r\n\r\n            The first input argument of the function needs to be x and this\r\n            argument must take a float-like input and return a float like object.\r\n            Other function parameters will be the fit parameters, these can\r\n            have custom names. Fit parameters will return in the same order as\r\n            their input, this order is also used in the formatter.\r\n\r\n            EXAMPLES\r\n                # Function that is equal to y = a exp(-bx)\r\n                def f(x: float, a: float, b: float) -> float:\r\n                    return a * np.exp(-1 * b * x)\r\n\r\n                format_str = r\"${0} e^{-{1} \\cdot x}$\" # Str containing the format\r\n                # Initialize the plot with data and function/format pair\r\n                plot_obj = Aplot(x, y, fx = f)\r\n                # Show the plot\r\n                plot_obj()\r\n\r\n                # Function that is equal to y = z * x^2 + h * x^(-4/7)\r\n                def g(x: float, h: float, z: float) -> float\r\n                    return z * x**2 + h * x**(4/7)\r\n                # Initialize the plot with data and function/format pair\r\n                plot_obj = Aplot(x, y, fx = g)\r\n                # Show the plot\r\n                plot_obj()\r\n\r\n        :param: func_format\r\n            Objecttype -> str.\r\n            The format of the function shown in the figure legend, this is\r\n            will overwrite the default label when used in combination with\r\n            the degree parameter.\r\n\r\n            EXAMPLE:\r\n                fx Contains a function which returns\r\n                    f(x) = a * exp(-b*x)\r\n                For a correct label func_form should be equivalent to\r\n                    r\"${0} e^{-{1} \\cdot x}$\"\r\n                the input doesnt necessarily need to be in a latex format.\r\n\r\n            CODE EXAMPLE:\r\n                # Function that is equal to y = a exp(-bx)\r\n                def f(x: float, a: float, b: float) -> float:\r\n                    return a * np.exp(-1 * b * x)\r\n\r\n                format_str = r\"${0} e^{-{1} \\cdot x}$\" # Str containing the format\r\n                # Initialize the plot with data and function/format pair\r\n                plot_obj = Aplot(x, y, fx = f, func_format = format_str)\r\n                # Show the plot\r\n                plot_obj()\r\n\r\n        :param: data_label\r\n            ObjectType -> str\r\n            Label of the data in the legend. Can include latex.\r\n\r\n        :param: colour\r\n            ObjectType -> str\r\n            Color of the data in one of the matplotlib accepted colors.\r\n            See matplotlib documentation for accepted colors.\r\n\r\n        :param: marker_fmt\r\n            ObjectType -> str\r\n            Marker of data points.\r\n\r\n        :param: custom_fit_spacing\r\n            ObjectType -> int\r\n            Length of the fitted data array. Min and Max are determined\r\n            by the min and max of the provided x data. Default is 1000 points.\r\n\r\n        :param: fit_precision\r\n\r\n\r\n        :param: grid\r\n\r\n\r\n        :param: response_var\r\n\r\n\r\n        :param: control_var\r\n\r\n        :param: add_mode\r\n            Default False when true doesnt initiate plt.subplots to make it\r\n            possible to add these graphs to another Aplot.Default plot.\r\n\r\n        :param: connecting_line\r\n            Default False, when True adds a connecting line in between\r\n            data points\r\n\r\n        :param: line_only\r\n            Default False, when True ONLY draws a connecting line between\r\n            data points.\r\n\r\n        :param: connecting_line_label\r\n            Default \"Connection\" object type str, is used as a label for the\r\n            connecting line only applicable when the connecting_line or line_mode\r\n            parameters are set to True.\r\n\r\n        :param: decimal_comma\r\n            Default True, if set to false\r\n\r\n        :param: file\r\n\r\n        :param: file_format\r\n            The format of the columns within the files, default is set to:\r\n             [\"x\", \"y\", \"x_err\", \"y_err\"]\r\n            Indicating that the first column is the x column, the second y, etc.\r\n\r\n            If the headers within the file are equal to the names in the file_format\r\n            the reader will detect these columns within the file note that\r\n            the headers of the file will need to be \"x\", \"y\", \"x_err\", \"y_err\"\r\n            for this to work.\r\n\r\n        :param: sigma_uncertainty\r\n            Either false or an Integer,\r\n            Adds an n-sigma uncertainty 'field' to the plot.\r\n\r\n        :param: uncertainty colour\r\n            Colour of the uncertainty lines\r\n\r\n    Usage:\r\n\r\n    Examples:\r\n    \"\"\"\r\n\r\n    def __init__(self, x: Union[tuple, list, np.ndarray, str] = None,\r\n                 y: Union[tuple, list, np.ndarray] = None, save_as: str = '',\r\n                 degree: Union[list, tuple, int] = None,\r\n                 *args, **kwargs):\r\n        super().__init__(x, y, *args, **kwargs)\r\n        self.save_as = save_as\r\n        test_inp(self.save_as, str, \"save as\")\r\n\r\n        self.func = None\r\n        self.degree = degree\r\n        if degree is not None:\r\n            test_inp(self.degree, (list, tuple, int, type(None)), \"x values\")\r\n            self.fit()\r\n        elif 'fx' in kwargs:\r\n            self.func = kwargs[\"fx\"]\r\n            test_inp(self.func, types.FunctionType, \"f(x)\")\r\n            self.fit()\r\n        else:\r\n            pass\r\n\r\n        self.connecting_line = False\r\n        if 'connecting_line' in kwargs:\r\n            test_inp(kwargs[\"connecting_line\"], bool, \"connecting_line\")\r\n            self.connecting_line = kwargs['connecting_line']\r\n\r\n        self.connecting_line_label = \"Connection\"\r\n        if 'connecting_line_label' in kwargs:\r\n            test_inp(kwargs[\"connecting_line_label\"], str, \"connecting_line_label\")\r\n            self.connecting_line_label = kwargs['connecting_line_label']\r\n\r\n        self.line_only = False\r\n        self.scatter = True\r\n        if 'line_only' in kwargs:\r\n            test_inp(kwargs[\"line_only\"], bool, \"line_only\")\r\n            self.connecting_line = kwargs['line_only']\r\n            self.scatter = not kwargs['line_only']\r\n\r\n        self.func_format = ''\r\n        if 'func_format' in kwargs:\r\n            test_inp(kwargs['func_format'], str, \"func_format\")\r\n            self.func_format = kwargs['func_format']\r\n\r\n        self.n_points = 1000\r\n        if \"custom_fit_spacing\" in kwargs:\r\n            test_inp(kwargs[\"custom_fit_spacing\"], int, \"fit array size\")\r\n            self.n_points = kwargs[\"custom_fit_spacing\"]\r\n\r\n        self.sigma_uncertainty = False\r\n        if \"sigma_uncertainty\" in kwargs:\r\n            self.sigma_uncertainty = kwargs[\"sigma_uncertainty\"]\r\n            test_inp(self.sigma_uncertainty, (bool, int), \"sigma_uncertainty\")\r\n\r\n        # ERROR ARRAYS\r\n        if 'x_err' in kwargs:\r\n            self.x_err = kwargs[\"x_err\"]\r\n            test_inp(self.x_err, (int, tuple, np.ndarray, list, float),\r\n                     \"x error\")\r\n            try:\r\n                if isinstance(self.x_err, (int, float)):\r\n                    self.x_err = np.full(self.x.size, self.x_err)\r\n\r\n                if isinstance(self.x_err, (tuple, list)):\r\n                    self.x_err = np.asarray(self.x_err)\r\n\r\n                assert self.x_err.size == self.x.size\r\n            except AssertionError:\r\n                raise IndexError(\"x Error and y list are not of the same size.\")\r\n        else:\r\n            self.x_err = []\r\n\r\n        if 'y_err' in kwargs:\r\n            self.y_err = kwargs[\"y_err\"]\r\n            test_inp(self.y_err, (int, tuple, np.ndarray, list, float),\r\n                     \"y error\")\r\n            try:\r\n                if isinstance(self.y_err, (int, float)):\r\n                    self.y_err = np.full(self.y.size, self.y_err)\r\n\r\n                if isinstance(self.y_err, (tuple, list)):\r\n                    self.y_err = np.asarray(self.y_err)\r\n\r\n                assert self.y_err.size == self.y.size\r\n            except AssertionError:\r\n                raise IndexError(\"y Error and y list are not of the same size.\")\r\n        else:\r\n            self.y_err = []\r\n\r\n        self.kwargs = kwargs\r\n        self.return_object = False\r\n\r\n    def __call__(self, *args, **kwargs) -> Tuple[plt.figure, plt.axes]:\r\n        \"\"\"\"\r\n        OPTIONAL:\r\n            :param: save_path\r\n                ObjectType -> str\r\n                Path to save the file to, default is the directory of the\r\n                .py file.\r\n            :param: return_object\r\n                ObjectType -> Bool\r\n                Default false, if true returns only the fig, ax object in a\r\n                tuple.\r\n        :returns\r\n            Tuple consisting of fig, ax objects\r\n\r\n        \"\"\"\r\n        # TODO: implement save_path\r\n        if \"save_path\" in kwargs:\r\n            test_inp(kwargs[\"save_path\"], str, \"save path\")\r\n            save_path = kwargs['save_path']\r\n        else:\r\n            try:\r\n                test_inp(args[0], str, \"save path\")\r\n                save_path = args[0]\r\n            except IndexError:\r\n                save_path = ''\r\n\r\n        if \"return_object\" in kwargs:\r\n            test_inp(kwargs[\"return_object\"], bool, \"return object\")\r\n            self.return_object = kwargs[\"return_object\"]\r\n        else:\r\n            # Maybe restructure this? Idk if I want to implement this option\r\n            # just a waste of time.\r\n            try:\r\n                test_inp(args[1], bool, \"return object\")\r\n                self.return_object = args[1]\r\n            except IndexError:\r\n                try:\r\n                    if save_path == '':\r\n                        test_inp(args[0], bool,\r\n                                 \"return object\")\r\n                        self.return_object = args[0]\r\n                except IndexError:\r\n                    pass\r\n\r\n        self.default_plot()\r\n\r\n        return self.fig, self.ax\r\n\r\n    def __add__(self, other):\r\n        test_inp(other, Default, \"Aplot.Default\")\r\n\r\n        other.fit()\r\n\r\n        if \"colour\" in other.kwargs:\r\n            test_inp(other.kwargs[\"colour\"], str, \"colour\")\r\n            color = other.kwargs[\"colour\"]\r\n        else:\r\n            color = \"C1\"\r\n\r\n        if other.scatter:\r\n            if len(other.y_err) == 0 and len(other.x_err) == 0:\r\n                self.ax.scatter(other.x, other.y, label=other.label, color=color)\r\n            elif len(other.y_err) == 0 or len(other.x_err) == 0:\r\n                if len(other.y_err) == 0:\r\n                    self.ax.errorbar(other.x, other.y, xerr=other.x_err,\r\n                                     label=other.label, fmt=color + 'o',\r\n                                     linestyle='',\r\n                                     capsize=4)\r\n                else:\r\n                    self.ax.errorbar(other.x, other.y, yerr=other.y_err,\r\n                                     label=other.label, fmt=color + 'o',\r\n                                     linestyle='',\r\n                                     capsize=4)\r\n            else:\r\n                self.ax.errorbar(other.x, other.y, xerr=other.x_err, yerr=other.y_err,\r\n                                 label=other.label, fmt=color + 'o',\r\n                                 linestyle='',\r\n                                 capsize=4)\r\n\r\n        if other.connecting_line:\r\n            self.ax.plot(other.x, other.y, label=other.connecting_line_label,\r\n                         color=color)\r\n\r\n        if other.sigma_uncertainty:\r\n            self.sigma_uncertainty(base=other)\r\n\r\n        fit_x = np.linspace(min(other.x), max(other.x), other.n_points)\r\n\r\n        fit_pr = 3\r\n        if \"fit_precision\" in other.kwargs:\r\n            test_inp(other.kwargs[\"fit_precision\"], int, \"fit precision\")\r\n            fit_pr = other.kwargs[\"fit_precision\"]\r\n\r\n        if other.degree is not None or other.func is not None:\r\n            if self.decimal_comma:\r\n                str_fit_coeffs = [str(np.around(c, fit_pr)).replace(\".\", \",\") for c\r\n                                  in\r\n                                  other.fit_coeffs]\r\n            else:\r\n                str_fit_coeffs = [str(np.around(c, fit_pr)) for c in\r\n                                  other.fit_coeffs]\r\n\r\n        if other.func is not None:\r\n            self.ax.plot(fit_x, other.func(fit_x, *other.fit_coeffs),\r\n                         linestyle=\"--\", c=color,\r\n                         label=(\r\n                             lambda _: other.func_format.format(*str_fit_coeffs)\r\n                             if other.func_format != \"\" else \"Fit\")(None))\r\n        elif other.degree is not None:\r\n            if other.func_format != '':\r\n                self.ax.plot(fit_x,\r\n                             sum([fit_x ** (c) * other.fit_coeffs[\r\n                                 abs(c - other.degree)]\r\n                                  for c in\r\n                                  range(other.degree + 1).__reversed__()]),\r\n                             linestyle=\"--\", c=color,\r\n                             label=(other.func_format.format(*str_fit_coeffs)))\r\n            else:\r\n                self.ax.plot(fit_x,\r\n                             sum([fit_x ** (c) * other.fit_coeffs[\r\n                                 abs(c - other.degree)]\r\n                                  for c in\r\n                                  range(other.degree + 1).__reversed__()]),\r\n                             linestyle=\"--\", c=color,\r\n                             label=(\r\n                                         \"Fit with function %s = \" % other.response_var +\r\n                                         other.degree_dict[other.degree].format(\r\n                                             *str_fit_coeffs)))\r\n\r\n\r\n        return self\r\n\r\n    def default_plot(self, show_error: bool = None,\r\n                     return_error: bool = None):\r\n        \"\"\"\r\n        Plot a 2D data set with errors in both x and y axes. The data\r\n        will be fitted according to the input arguments in __innit__.\r\n\r\n        Requires a Aplot object to plot with x, y or file input.\r\n\r\n        OPTIONAL\r\n        :param: show_error\r\n            ObjectType -> bool\r\n            Default, True when true prints out the error in the\r\n            coefficients. When changed from default overwrites the print_error\r\n            statement in __innit__.\r\n\r\n        :param: return_error\r\n            Objecttype -> bool\r\n            Default, False when true returns a dictionary with coefficients,\r\n            \"coeffs\" and error \"error\" of the fit parameters.\r\n\r\n        EXAMPLES\r\n        plot and show fig\r\n        x, y = data\r\n        plot_obj = Aplot(x, y, degree=1) # Linear fit to x and y data\r\n        plot_obj.default_plot()\r\n\r\n        plot and save fig as plot.png\r\n        x, y = data\r\n        plot_obj = Aplot(x, y, degree=1, save_as='plot.png') # Linear fit to x and y data\r\n        plot_obj.default_plot()\r\n\r\n\r\n        :return: Optional[dict[str, Union[Union[ndarray, Iterable, int, float], Any]]]\r\n        \"\"\"\r\n        # DATA PLOTTING\r\n        # TODO: add these extra kwargs to the docs\r\n\r\n        if \"colour\" in self.kwargs:\r\n            test_inp(self.kwargs[\"colour\"], str, \"colour\")\r\n            color = self.kwargs[\"colour\"]\r\n        else:\r\n            color = \"C0\"\r\n\r\n        if \"marker_fmt\" in self.kwargs:\r\n            test_inp(self.kwargs[\"marker_fmt\"], str, \"marker format\")\r\n            mark = self.kwargs[\"marker_fmt\"]\r\n        else:\r\n            mark = \"C0\"\r\n\r\n        if self.scatter:\r\n            if len(self.y_err) == 0 and len(self.x_err) == 0:\r\n                self.ax.scatter(self.x, self.y, label=self.label, color=color)\r\n            elif len(self.y_err) == 0 or len(self.x_err) == 0:\r\n                if len(self.y_err) == 0:\r\n                    self.ax.errorbar(self.x, self.y, xerr=self.x_err,\r\n                                     label=self.label, fmt=color + mark,\r\n                                     linestyle='',\r\n                                     capsize=4)\r\n                else:\r\n                    self.ax.errorbar(self.x, self.y, yerr=self.y_err,\r\n                                     label=self.label, fmt=color + mark,\r\n                                     linestyle='',\r\n                                     capsize=4)\r\n            else:\r\n                self.ax.errorbar(self.x, self.y, xerr=self.x_err, yerr=self.y_err,\r\n                                 label=self.label, fmt=color + mark, linestyle='',\r\n                                 capsize=4)\r\n\r\n        if self.connecting_line:\r\n            self.ax.plot(self.x, self.y, label=self.connecting_line_label,\r\n                         color=color)\r\n\r\n        # FIT PLOTTING\r\n        if show_error:\r\n            print(self.fit_errors)\r\n\r\n        fit_x = np.linspace(min(self.x), max(self.x), self.n_points)\r\n\r\n        fit_pr = 3\r\n        if \"fit_precision\" in self.kwargs:\r\n            test_inp(self.kwargs[\"fit_precision\"], int, \"fit precision\")\r\n            fit_pr = self.kwargs[\"fit_precision\"]\r\n\r\n        if TNFormatter:\r\n            if self.degree is not None or self.func is not None:\r\n                str_fit_coeffs = [str(np.around(c, fit_pr)).replace(\".\", \",\") for c\r\n                                  in\r\n                                  self.fit_coeffs]\r\n        else:\r\n            if self.degree is not None or self.func is not None:\r\n                str_fit_coeffs = [str(np.around(c, fit_pr)) for c in self.fit_coeffs]\r\n\r\n        if self.func is not None:\r\n            self.ax.plot(fit_x, self.func(fit_x, *self.fit_coeffs),\r\n                         linestyle=\"--\", c=color,\r\n                         label=(\r\n                             lambda _: self.func_format.format(*str_fit_coeffs)\r\n                             if self.func_format != \"\" else \"Fit\")(None))\r\n        elif self.degree is not None:\r\n            if self.func_format != '':\r\n                self.ax.plot(fit_x,\r\n                             sum([fit_x ** (c) * self.fit_coeffs[\r\n                                 abs(c - self.degree)]\r\n                                  for c in\r\n                                  range(self.degree + 1).__reversed__()]),\r\n                             linestyle=\"--\", c=color,\r\n                             label=(self.func_format.format(*str_fit_coeffs)))\r\n            else:\r\n                self.ax.plot(fit_x,\r\n                             sum([fit_x ** (c) * self.fit_coeffs[\r\n                                 abs(c - self.degree)]\r\n                                  for c in\r\n                                  range(self.degree + 1).__reversed__()]),\r\n                             linestyle=\"--\", c=color,\r\n                             label=(\r\n                                         \"Fit with function %s = \" % self.response_var +\r\n                                         self.degree_dict[self.degree].format(\r\n                                             *str_fit_coeffs)))\r\n\r\n        if self.sigma_uncertainty:\r\n            self.add_sigma_uncertainty()\r\n\r\n        y_label = ''\r\n        if \"y_label\" in self.kwargs:\r\n            test_inp(self.kwargs[\"y_label\"], str, \"y_label\")\r\n            y_label = self.kwargs[\"y_label\"]\r\n\r\n        x_label = ''\r\n        if \"x_label\" in self.kwargs:\r\n            test_inp(self.kwargs[\"x_label\"], str, \"x_label\")\r\n            x_label = self.kwargs[\"x_label\"]\r\n\r\n        grid = True\r\n        if \"grid\" in self.kwargs:\r\n            test_inp(self.kwargs[\"grid\"], bool, \"grid\")\r\n            grid = self.kwargs[\"grid\"]\r\n\r\n        super().single_form(x_label, y_label, grid=grid, fig_ax=(self.fig, self.ax))\r\n\r\n        if not self.return_object:\r\n            (lambda save_as:\r\n             plt.show() if save_as == '' else plt.savefig(save_as,\r\n                                                          bbox_inches='tight')\r\n             )(self.save_as)\r\n\r\n        if return_error:\r\n            return {\"Coeffs\": self.fit_coeffs, \"Errors\": self.fit_errors}\r\n\r\n        return None\r\n\r\n    def fit(self) -> Optional[Dict[str, Union[np.ndarray, Iterable, int, float]]]:\r\n        \"\"\"\r\n        Calculate the fit parameters of an Aplot object.\r\n\r\n        This function calculates the fit parameters based on either a polyfit or\r\n        function fit. Where the function fit takes in a python function type,\r\n        with first argument x and other arguments being the parameters.\r\n\r\n        param show_fit -> moved to the fit_stats function\r\n\r\n        :returns:\r\n            None\r\n\r\n        EXAMPLE WITH FUNCTION:\r\n            # Function that depicts y = exp(-x + sqrt(a * x)) + b\r\n            def f(x: float, a: float, b: float) -> float:\r\n                return np.exp(-1*x + np.sqrt(a * x)) + b\r\n\r\n            # load the data into an Aplot object\r\n            plot_obj = Aplot(x, y, fx=f)\r\n\r\n            # Run the fit attr with show_fit set to True.\r\n            plot_obj.fit(True)\r\n\r\n        EXAMPLE WITHOUT FUNCTION:\r\n            # load the data into an Aplot object and set the degree variable\r\n            plot_obj = Aplot(x, y, degree=1) # Linear data\r\n\r\n            # Run the fit attr with show_fit set to True.\r\n            plot_obj.fit(True)\r\n\r\n        \"\"\"\r\n\r\n        self.degree_dict = {\r\n            0: '{0}',\r\n            1: '${0}%s + {1}$' % self.control_var,\r\n            2: r'${0}%s^2 + {1}%s + {2}$' % (\r\n            self.control_var, self.control_var),\r\n            3: r'${0}%s^3 + {1}%s^2 + {2}%s + {3}$' % tuple(\r\n                [self.control_var for _ in range(3)]),\r\n            4: r'${0}%s^4 + {1}%s^3 + {2}%s^2 + {3}%s + {4}$' % tuple(\r\n                [self.control_var for _ in range(4)]),\r\n            5: r'${0}%s^5 + {1}%s^4 + {2}%s^3 + {3}%s^2 + {4}%s + {5}$' % tuple(\r\n                [self.control_var for _ in range(5)])\r\n        }\r\n\r\n        if self.degree is not None:\r\n            self.label_format = self.degree_dict[self.degree]\r\n            if isinstance(self.degree, int):\r\n                fit = np.polyfit(self.x, self.y, deg=self.degree, cov=True)\r\n                self.fit_coeffs = fit[0]\r\n                self.fit_errors = np.sqrt(np.diag(fit[1]))\r\n        elif self.func is not None:\r\n            fit, pcov = curve_fit(self.func, self.x, self.y)\r\n            self.fit_coeffs = fit\r\n            self.fit_errors = np.sqrt(np.diag(pcov))\r\n\r\n        return None\r\n\r\n    def lambdify_fit(self) -> Callable:\r\n        \"\"\"\r\n        Turn the fitted line into a lambda function to manually calculate\r\n        desired values.\r\n        :return: lambda function, Object type Callable\r\n        \"\"\"\r\n        if self.func is not None:\r\n            return lambda x: self.func(x, *self.fit_coeffs)\r\n        elif self.degree is not None:\r\n            return lambda x: sum([x ** (c) * self.fit_coeffs[abs(c - self.degree)]\r\n                                  for c in range(self.degree + 1).__reversed__()])\r\n        else:\r\n            raise AttributeError(\"Missing parameters to compute fit\"\r\n                                 \" coefficients, add either 'degree' or 'fx'\"\r\n                                 \"to the parameters.\")\r\n\r\n    def fit_stats(self) -> Dict:\r\n        \"\"\"\r\n        Return fit values in a dictionary.\r\n\r\n        The dictionary format is {\"c\": list of coefficients, \"e\": list of errors}\r\n\r\n        Where the order of coefficients and errors is the same as defined in the\r\n        given fit function or from highest order to lowest order when defined\r\n        by the degree parameter.\r\n\r\n        :return: Dictionary consisting out of fit coefficients and error in the\r\n                 coefficients.\r\n        \"\"\"\r\n        return {\"c\": self.fit_coeffs, \"e\": self.fit_errors}\r\n\r\n    def add_sigma_uncertainty(self, base=None, linestyle: str = \"--\"):\r\n        \"\"\"\r\n        Uses the sum of the errors in the fit to calculate an n-sigma\r\n        fit boundary. The method uses the SUM meaning this method is only feasible\r\n        for linear regressions.\r\n        :param base:\r\n            Base object from which the data is being pulled\r\n        :param linestyle:\r\n            Linestyle of the sigma line.\r\n        :return:\r\n        \"\"\"\r\n        if base is None:\r\n            base = self\r\n\r\n        sigma_label: str = base.kwargs[\"sigma_label\"] if \"sigma_label\" in\\\r\n                                                         base.kwargs else\\\r\n                                                        \"%s sigma boundary\" % base.sigma_uncertainty\r\n        sigma_colour: str = base.kwargs[\"sigma_colour\"] if \"sigma_colour\" in\\\r\n                                                         base.kwargs else \"gray\"\r\n\r\n        x_vals = np.linspace(min(self.x), max(self.x), self.n_points)\r\n        if self.func is not None:\r\n            # Plot the lower bound\r\n            self.ax.plot(x_vals,\r\n                         y=base.func(x_vals, *base.fit_coeffs) - sum(base.fit_errors),\r\n                         linestyle=linestyle,\r\n                         c=sigma_colour, label=sigma_label)\r\n            self.ax.plot(x_vals,\r\n                         base.func(x_vals, *base.fit_coeffs) + sum(base.fit_errors),\r\n                         linestyle=linestyle,\r\n                         c=sigma_colour)\r\n        else:\r\n            lower_y = np.asarray(sum([x_vals ** (c) * base.fit_coeffs[abs(c - self.degree)]\r\n                           for c in range(self.degree + 1).__reversed__()])) - sum(base.fit_errors)\r\n            upper_y = np.asarray(sum([x_vals ** (c) * base.fit_coeffs[abs(c - self.degree)]\r\n                           for c in range(self.degree + 1).__reversed__()])) + sum(base.fit_errors)\r\n\r\n            self.ax.plot(x_vals, lower_y, linestyle=linestyle,\r\n                         c=sigma_colour, label=sigma_label)\r\n            self.ax.plot(x_vals, upper_y, linestyle=linestyle,\r\n                         c=sigma_colour)\r\n        return None\r\n\r\n\r\nclass Multi:\r\n\r\n    def __innit__(self):\r\n        pass\r\n\r\n    def __call__(self):\r\n        pass\r\n\r\n\r\nclass Hist:\r\n\r\n    def __innit__(self):\r\n        pass\r\n\r\n    def __call__(self):\r\n        pass\r\n\r\n    def histogram(self):\r\n        \"\"\"\r\n\r\n        :return:\r\n        \"\"\"\r\n        self.fig, self.ax = plt.subplots()\r\n\r\n        bins = int(np.round(len(self.x) / np.sqrt(2)))\r\n        if \"binning\" in self.kwargs:\r\n            bins = self.kwargs[\"binning\"]\r\n            try:\r\n                bins = int(bins)\r\n            except ValueError:\r\n                raise ValueError(\"Bins must be an integer or convertible to an\"\r\n                                 \" integer.\")\r\n\r\n            test_inp(bins, int, \"binning\", True)\r\n\r\n        norm_label = \"Label\"\r\n        if \"norm_label\" in self.kwargs:\r\n            norm_label = self.kwargs[\"norm_label\"]\r\n            test_inp(norm_label, str, \"norm label\")\r\n\r\n        if \"sigma_lines\" in self.kwargs:\r\n            pass\r\n\r\n        self.ax.hist(self.x, bins=bins, label=self.label)\r\n\r\n        norm_dist = self.norm_dist_plot()\r\n        self.ax.plot(norm_dist[0], norm_dist[1], label=norm_label)\r\n\r\n        y_label = ''\r\n        if \"y_label\" in self.kwargs:\r\n            test_inp(self.kwargs[\"y_label\"], str, \"y_label\")\r\n            y_label = self.kwargs[\"y_label\"]\r\n\r\n        x_label = ''\r\n        if \"x_label\" in self.kwargs:\r\n            test_inp(self.kwargs[\"x_label\"], str, \"x_label\")\r\n            x_label = self.kwargs[\"x_label\"]\r\n\r\n        grid = True\r\n        if \"grid\" in self.kwargs:\r\n            test_inp(self.kwargs[\"grid\"], bool, \"grid\")\r\n            grid = self.kwargs[\"grid\"]\r\n\r\n        self.single_form(x_label, y_label, grid)\r\n\r\n        if not self.return_object:\r\n            (lambda save_as:\r\n             plt.show() if save_as == '' else plt.savefig(save_as,\r\n                                                          bbox_inches='tight')\r\n             )(self.save_as)\r\n\r\n        return None\r\n\r\n    def norm_dist_plot(self, scaling: bool = True):\r\n        \"\"\"\r\n\r\n        :return:\r\n        \"\"\"\r\n        if \"x_lim\" in self.kwargs:\r\n            x = np.linspace(self.x_lim[0], self.x_lim[1], self.n_points)\r\n        else:\r\n            x = np.linspace(min(self.x) + max(self.x) * 1 / 10,\r\n                            max(self.x) + max(self.x) * 1 / 10, self.n_points)\r\n\r\n        mu, std = np.average(x), np.std(x)\r\n        dist = scipy.stats.norm.pdf(x, mu, std)\r\n\r\n        if scaling:\r\n            factor = np.average(self.x) / np.max(dist)\r\n            if \"scaling_factor\" in self.kwargs:\r\n                factor = self.kwargs[\"scaling_factor\"]\r\n                test_inp(factor, (float, int), \"scaling factor\")\r\n            dist = dist * abs(factor)\r\n\r\n        return x, dist, mu\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    import time\r\n    import Aplot\r\n\r\n    t_start = time.time()\r\n\r\n\r\n    def f(x: float, a: float, b: float) -> float:\r\n        return a * x ** 2 + b * x\r\n\r\n\r\n    points = 40\r\n    x = np.linspace(-5, 5, points)\r\n    noise = np.random.randint(-2, 2, points)\r\n    plot = Default(x=x, y=np.array([i * -4.32 + 9.123 for i in x] + noise),\r\n          y_err=10, x_err=0.1, y_lim=[-50, 50], x_label=\"bruh x\", y_label=\"bruh y\", degree=2,\r\n                   connecting_line=True,\r\n                   func_format=\"$y_{{result}} = {0} \\cdot \\cos{{ (x_{{func}} \\cdot {1}) }} + {0}^{{x_{{func}} + {2}}}$\")\r\n    \r\n    add = Default(x=x, y=np.array([i * 4.4 + 0.12 for i in x] + noise),\r\n          y_err=10, x_err=0.1, add_mode=True, line_mode=True, degree=2)\r\n    # hist = Aplot([3, 2, 3, 1, 3, 4, 2, 4, 5, 6, 5], mode=\"hist\", x_lim=[0, 7],\r\n    #              x_label=\"X-as\", grid=False)()\r\n    plot += add\r\n\r\n    plot()\r\n\r\n    print(\"t: \", time.time() - t_start)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/AdrianPack/Aplot.py b/AdrianPack/Aplot.py
--- a/AdrianPack/Aplot.py	(revision 29eda08cd6491e53d62be7d02b43f697964fa529)
+++ b/AdrianPack/Aplot.py	(date 1654970240006)
@@ -22,7 +22,6 @@
 except ImportError:
     from .Helper import test_inp
 
-# TODO: plot straight from files
 # TODO: plot normal distrubtion over histogram
 # TODO: plot bodeplots (maybe?)
 
@@ -1054,19 +1053,10 @@
         return None
 
 
-class Multi:
+class Hist(Base):
 
-    def __innit__(self):
-        pass
-
-    def __call__(self):
-        pass
-
-
-class Hist:
-
-    def __innit__(self):
-        pass
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
 
     def __call__(self):
         pass
@@ -1151,6 +1141,14 @@
         return x, dist, mu
 
 
+class Multi:
+
+    def __innit__(self):
+        pass
+
+    def __call__(self):
+        pass
+
 if __name__ == "__main__":
     import time
     import Aplot
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"e9db8f2b-0092-46ad-9797-cd929e612058\" name=\"Default Changelist\" comment=\"Aplot.py:&#10; Added the ability to plot files and reworked the matrix plot function to utilise the same formatter.&#10; &#10;ODE.py:&#10; Fixed a bug in the new decorator that disabled the ability to use the functions without a listed argument.&#10; &#10;Since the file and plot integration is added the package is now in release 0.0.3\">\r\n      <change beforePath=\"$PROJECT_DIR$/AdrianPack/Aplot.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/AdrianPack/Aplot.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/setup.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/setup.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GitSEFilterConfiguration\">\r\n    <file-type-list>\r\n      <filtered-out-file-type name=\"LOCAL_BRANCH\" />\r\n      <filtered-out-file-type name=\"REMOTE_BRANCH\" />\r\n      <filtered-out-file-type name=\"TAG\" />\r\n      <filtered-out-file-type name=\"COMMIT_BY_MESSAGE\" />\r\n    </file-type-list>\r\n  </component>\r\n  <component name=\"NamedScopeManager\">\r\n    <scope name=\"func\" pattern=\"\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"23vr99F43tyljxLA862UdUuFavm\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showExcludedFiles\" value=\"false\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n    <option name=\"showMembers\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">\r\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\r\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\r\n    <property name=\"SHARE_PROJECT_CONFIGURATION_FILES\" value=\"true\" />\r\n    <property name=\"WebServerToolWindowFactoryState\" value=\"false\" />\r\n    <property name=\"com.intellij.ide.scratch.LRUPopupBuilder$1/New Scratch File\" value=\"Python\" />\r\n    <property name=\"node.js.detected.package.eslint\" value=\"true\" />\r\n    <property name=\"node.js.detected.package.tslint\" value=\"true\" />\r\n    <property name=\"node.js.selected.package.eslint\" value=\"(autodetect)\" />\r\n    <property name=\"node.js.selected.package.tslint\" value=\"(autodetect)\" />\r\n    <property name=\"settings.editor.selected.configurable\" value=\"com.jetbrains.python.configuration.PyActiveSdkModuleConfigurable\" />\r\n  </component>\r\n  <component name=\"RunManager\" selected=\"Python.simple_fit\">\r\n    <configuration name=\"air_res_plot\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"AdrianPack_src\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Examples/Aplot\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Examples/Aplot/air_res_plot.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"example_txtread\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"AdrianPack_src\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Examples/csvread\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Examples/csvread/example_txtread.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"label_formatter\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"AdrianPack_src\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Examples/Aplot\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Examples/Aplot/label_formatter.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"plot_from_file\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"AdrianPack_src\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Examples/Aplot\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Examples/Aplot/plot_from_file.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"simple_fit\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"AdrianPack_src\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/Examples/Aplot\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Examples/Aplot/simple_fit.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python.simple_fit\" />\r\n        <item itemvalue=\"Python.air_res_plot\" />\r\n        <item itemvalue=\"Python.plot_from_file\" />\r\n        <item itemvalue=\"Python.label_formatter\" />\r\n        <item itemvalue=\"Python.example_txtread\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"e9db8f2b-0092-46ad-9797-cd929e612058\" name=\"Default Changelist\" comment=\"\" />\r\n      <created>1642625250244</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1642625250244</updated>\r\n      <workItem from=\"1642625253905\" duration=\"966000\" />\r\n      <workItem from=\"1642628482440\" duration=\"25000\" />\r\n      <workItem from=\"1642628622530\" duration=\"804000\" />\r\n      <workItem from=\"1642638383667\" duration=\"16000\" />\r\n      <workItem from=\"1642705708340\" duration=\"355000\" />\r\n      <workItem from=\"1642855078443\" duration=\"17140000\" />\r\n      <workItem from=\"1642941624019\" duration=\"4181000\" />\r\n      <workItem from=\"1643142808935\" duration=\"1219000\" />\r\n      <workItem from=\"1643237521062\" duration=\"951000\" />\r\n      <workItem from=\"1644332048068\" duration=\"62000\" />\r\n      <workItem from=\"1645195986229\" duration=\"2659000\" />\r\n      <workItem from=\"1645624894907\" duration=\"21479000\" />\r\n      <workItem from=\"1645722068918\" duration=\"14800000\" />\r\n      <workItem from=\"1645794830481\" duration=\"19236000\" />\r\n      <workItem from=\"1645896878900\" duration=\"651000\" />\r\n      <workItem from=\"1646148231162\" duration=\"6622000\" />\r\n      <workItem from=\"1646309676601\" duration=\"20641000\" />\r\n      <workItem from=\"1646388028538\" duration=\"10448000\" />\r\n      <workItem from=\"1646492740970\" duration=\"57000\" />\r\n      <workItem from=\"1646608006729\" duration=\"1259000\" />\r\n      <workItem from=\"1646609310962\" duration=\"8000\" />\r\n      <workItem from=\"1647542669004\" duration=\"8996000\" />\r\n      <workItem from=\"1647599346243\" duration=\"5726000\" />\r\n      <workItem from=\"1649364813247\" duration=\"1816000\" />\r\n      <workItem from=\"1649538484373\" duration=\"627000\" />\r\n      <workItem from=\"1651250409148\" duration=\"3578000\" />\r\n      <workItem from=\"1651750747619\" duration=\"4797000\" />\r\n      <workItem from=\"1652120778549\" duration=\"3100000\" />\r\n      <workItem from=\"1652199083366\" duration=\"3019000\" />\r\n      <workItem from=\"1652207425676\" duration=\"7366000\" />\r\n      <workItem from=\"1652801898456\" duration=\"18284000\" />\r\n      <workItem from=\"1652888208526\" duration=\"13703000\" />\r\n      <workItem from=\"1653341954947\" duration=\"701000\" />\r\n      <workItem from=\"1653508184303\" duration=\"4726000\" />\r\n      <workItem from=\"1653564518924\" duration=\"1192000\" />\r\n      <workItem from=\"1653695376758\" duration=\"2329000\" />\r\n      <workItem from=\"1653773128146\" duration=\"607000\" />\r\n      <workItem from=\"1653923821433\" duration=\"416000\" />\r\n      <workItem from=\"1654894755084\" duration=\"9941000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"Updated csvread function\">\r\n      <created>1642627626760</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1642627626760</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"Updated setup.py\">\r\n      <created>1642628495005</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1642628495005</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"Updated setup.py\">\r\n      <created>1642628676535</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1642628676536</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"Updated setup.py\">\r\n      <created>1642628965033</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1642628965033</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"Added entries to the csvread docstring\">\r\n      <created>1642706053899</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1642706053899</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00006\" summary=\"Added a function to compress 1D arrays using a floating average.\">\r\n      <created>1642864527658</created>\r\n      <option name=\"number\" value=\"00006\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1642864527658</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00007\" summary=\"Added a function to compress 1D arrays using a floating average.\">\r\n      <created>1642867806617</created>\r\n      <option name=\"number\" value=\"00007\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1642867806617</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00008\" summary=\"Added a function to compress 1D arrays using a floating average.\">\r\n      <created>1642869255559</created>\r\n      <option name=\"number\" value=\"00008\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1642869255559</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00009\" summary=\"Added a function to compress 1D arrays using a floating average.\">\r\n      <created>1642942128539</created>\r\n      <option name=\"number\" value=\"00009\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1642942128539</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00010\" summary=\"Reworked the plot function.&#10;Plot function now uses a class structure with modular blocks to plot data and fit that data. The fitted data also has errors in the fitted coefficients and data provided can include errorbars.\">\r\n      <created>1645815532990</created>\r\n      <option name=\"number\" value=\"00010\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1645815532990</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00011\" summary=\"Aplot:&#10;Updated docs for the main class: x, y, mode, func_format&#10;and several other subfunctions&#10;csvread:&#10;Removed a print statement\">\r\n      <created>1646317378655</created>\r\n      <option name=\"number\" value=\"00011\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1646317378655</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00012\" summary=\"Added ability to plot histogram\">\r\n      <created>1646405436397</created>\r\n      <option name=\"number\" value=\"00012\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1646405436397</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00013\" summary=\"Several small updates\">\r\n      <created>1646608778614</created>\r\n      <option name=\"number\" value=\"00013\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1646608778614</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00014\" summary=\"VERSION 0.0.2 RELEASE&#10;&#10;CHANGES TO Aplot.py&#10;Full restructure of Aplot from single class to multiple classes with a common&#10;parent class. See documentation for further reference.&#10;Changes include but are not limited to:&#10; - Ability to plot data without adding a fit&#10; - Easier to plot different types of plots (called by their own classes IE an histogram object is build with Aplot.hist())&#10; - Easier to understand and more intuitive function parameters and documentation of these.&#10; &#10;CHANGES TO Extra.py&#10;Added a gauss elimination function to Extra.py .\">\r\n      <created>1649366799780</created>\r\n      <option name=\"number\" value=\"00014\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00014\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1649366799780</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00015\" summary=\"VERSION 0.0.2 RELEASE&#10;&#10;Added runga kutta approximation  methods for ODEs to ODE.py.\">\r\n      <created>1652206967407</created>\r\n      <option name=\"number\" value=\"00015\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00015\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1652206967407</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00016\" summary=\"Fixed an import error in ODE.py\">\r\n      <created>1652207485744</created>\r\n      <option name=\"number\" value=\"00016\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00016\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1652207485744</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00017\" summary=\"Fixed an error in Aplot.py, dataplotting without including a fit is now allowed.\">\r\n      <created>1652810714782</created>\r\n      <option name=\"number\" value=\"00017\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00017\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1652810714782</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00018\" summary=\"Added the ability to add multiple graphs together.\">\r\n      <created>1652832256790</created>\r\n      <option name=\"number\" value=\"00018\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00018\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1652832256790</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00019\" summary=\"Added the ability to add multiple graphs together.\">\r\n      <created>1652899950331</created>\r\n      <option name=\"number\" value=\"00019\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00019\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1652899950331</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00020\" summary=\"Added the ability to add multiple graphs together.\">\r\n      <created>1652900669841</created>\r\n      <option name=\"number\" value=\"00020\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00020\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1652900669841</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00021\" summary=\"Added the ability to add multiple graphs together.\">\r\n      <created>1652901869892</created>\r\n      <option name=\"number\" value=\"00021\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00021\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1652901869892</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00022\" summary=\"Changed csvread.py to Fileread.py, the class csvread is also called Fileread it is still possible to call csvread until update 0.0.4 (current update is 0.0.2).\">\r\n      <created>1652902087174</created>\r\n      <option name=\"number\" value=\"00022\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00022\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1652902087174</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00023\" summary=\"Added the option to turn of the decimal comma and TN_code now only needs to be placed within the same folder as where the code is ran from.\">\r\n      <created>1652911757297</created>\r\n      <option name=\"number\" value=\"00023\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00023\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1652911757297</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00024\" summary=\"Added the option to turn of the decimal comma and TN_code now only needs to be placed within the same folder as where the code is ran from.\">\r\n      <created>1653695534584</created>\r\n      <option name=\"number\" value=\"00024\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00024\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1653695534585</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00025\" summary=\"Add the option &quot;show_fit&quot; to .fit() method parameters, this will now return the fit coefficients and errors in a dictionary in the order specified by either fx or from n^ith polynomial where as n^i, n^i-1, n^i-2 ... n^0.\">\r\n      <created>1653924104848</created>\r\n      <option name=\"number\" value=\"00025\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00025\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1653924104848</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00026\" summary=\"Aplot.py:\">\r\n      <created>1654961404050</created>\r\n      <option name=\"number\" value=\"00026\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00026\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1654961404050</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00027\" summary=\"Aplot.py:&#10; Added the ability to plot files and reworked the matrix plot function to utilise the same formatter.&#10; &#10;ODE.py:&#10; Fixed a bug in the new decorator that disabled the ability to use the functions without a listed argument.&#10; &#10;Since the file and plot integration is added the package is now in release 0.0.3\">\r\n      <created>1654961547440</created>\r\n      <option name=\"number\" value=\"00027\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00027\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1654961547440</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00028\" summary=\"Aplot.py:&#10; Added the ability to plot files and reworked the matrix plot function to utilise the same formatter.&#10; &#10;ODE.py:&#10; Fixed a bug in the new decorator that disabled the ability to use the functions without a listed argument.&#10; &#10;Since the file and plot integration is added the package is now in release 0.0.3\">\r\n      <created>1654961979488</created>\r\n      <option name=\"number\" value=\"00028\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00028\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1654961979488</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"29\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n    <option name=\"oldMeFiltersMigrated\" value=\"true\" />\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"Updated csvread function\" />\r\n    <MESSAGE value=\"Updated setup.py\" />\r\n    <MESSAGE value=\"Added entries to the csvread docstring\" />\r\n    <MESSAGE value=\"Added a function to compress 1D arrays using a floating average.\" />\r\n    <MESSAGE value=\"Reworked the plot function.&#10;Plot function now uses a class structure with modular blocks to plot data and fit that data. The fitted data also has errors in the fitted coefficients and data provided can include errorbars.\" />\r\n    <MESSAGE value=\"Aplot:&#10;Updated docs for the main class: x, y, mode, func_format&#10;and several other subfunctions&#10;csvread:&#10;Removed a print statement\" />\r\n    <MESSAGE value=\"Added ability to plot histogram\" />\r\n    <MESSAGE value=\"Several small updates\" />\r\n    <MESSAGE value=\"VERSION 0.0.2 RELEASE&#10;&#10;CHANGES TO Aplot.py&#10;Full restructure of Aplot from single class to multiple classes with a common&#10;parent class. See documentation for further reference.&#10;Changes include but are not limited to:&#10; - Ability to plot data without adding a fit&#10; - Easier to plot different types of plots (called by their own classes IE an histogram object is build with Aplot.hist())&#10; - Easier to understand and more intuitive function parameters and documentation of these.&#10; &#10;CHANGES TO Extra.py&#10;Added a gauss elimination function to Extra.py .\" />\r\n    <MESSAGE value=\"VERSION 0.0.2 RELEASE&#10;&#10;Added runga kutta approximation  methods for ODEs to ODE.py.\" />\r\n    <MESSAGE value=\"Fixed an import error in ODE.py\" />\r\n    <MESSAGE value=\"Fixed an error in Aplot.py, dataplotting without including a fit is now allowed.\" />\r\n    <MESSAGE value=\"Added the ability to add multiple graphs together.\" />\r\n    <MESSAGE value=\"Changed csvread.py to Fileread.py, the class csvread is also called Fileread it is still possible to call csvread until update 0.0.4 (current update is 0.0.2).\" />\r\n    <MESSAGE value=\"Added the option to turn of the decimal comma and TN_code now only needs to be placed within the same folder as where the code is ran from.\" />\r\n    <MESSAGE value=\"Add the option &quot;show_fit&quot; to .fit() method parameters, this will now return the fit coefficients and errors in a dictionary in the order specified by either fx or from n^ith polynomial where as n^i, n^i-1, n^i-2 ... n^0.\" />\r\n    <MESSAGE value=\"Aplot.py:\" />\r\n    <MESSAGE value=\"Aplot.py:&#10; Added the ability to plot files and reworked the matrix plot function to utilise the same formatter.&#10; &#10;ODE.py:&#10; Fixed a bug in the new decorator that disabled the ability to use the functions without a listed argument.&#10; &#10;Since the file and plot integration is added the package is now in release 0.0.3\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"Aplot.py:&#10; Added the ability to plot files and reworked the matrix plot function to utilise the same formatter.&#10; &#10;ODE.py:&#10; Fixed a bug in the new decorator that disabled the ability to use the functions without a listed argument.&#10; &#10;Since the file and plot integration is added the package is now in release 0.0.3\" />\r\n  </component>\r\n  <component name=\"com.intellij.coverage.CoverageDataManagerImpl\">\r\n    <SUITE FILE_PATH=\"coverage/AdrianPack_src$Aplot.coverage\" NAME=\"Aplot Coverage Results\" MODIFIED=\"1646608741737\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/AdrianPack\" />\r\n    <SUITE FILE_PATH=\"coverage/AdrianPack_src$utils.coverage\" NAME=\"utils Coverage Results\" MODIFIED=\"1642862350474\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/venv/Lib/site-packages/numpy/testing/_private\" />\r\n    <SUITE FILE_PATH=\"coverage/setup_py$plot_from_file.coverage\" NAME=\"plot_from_file Coverage Results\" MODIFIED=\"1654961510160\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Examples/Aplot\" />\r\n    <SUITE FILE_PATH=\"coverage/AdrianPack_src$Helper.coverage\" NAME=\"Helper Coverage Results\" MODIFIED=\"1642867648501\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/AdrianPack\" />\r\n    <SUITE FILE_PATH=\"coverage/setup_py$label_formatter.coverage\" NAME=\"label_formatter Coverage Results\" MODIFIED=\"1654960735366\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Examples/Aplot\" />\r\n    <SUITE FILE_PATH=\"coverage/setup_py$Aplot.coverage\" NAME=\"Aplot Coverage Results\" MODIFIED=\"1654960058177\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/AdrianPack\" />\r\n    <SUITE FILE_PATH=\"coverage/setup_py$example_txtread.coverage\" NAME=\"example_txtread Coverage Results\" MODIFIED=\"1654960677288\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Examples/csvread\" />\r\n    <SUITE FILE_PATH=\"coverage/setup_py$ODE.coverage\" NAME=\"ODE Coverage Results\" MODIFIED=\"1654960274696\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/AdrianPack\" />\r\n    <SUITE FILE_PATH=\"coverage/setup_py$air_res_plot.coverage\" NAME=\"air_res_plot Coverage Results\" MODIFIED=\"1654967044232\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Examples/Aplot\" />\r\n    <SUITE FILE_PATH=\"coverage/AdrianPack_src$scratch_15.coverage\" NAME=\"scratch_15 Coverage Results\" MODIFIED=\"1643237869471\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$APPLICATION_CONFIG_DIR$/scratches\" />\r\n    <SUITE FILE_PATH=\"coverage/AdrianPack_src$Extra_test.coverage\" NAME=\"Extra_test Coverage Results\" MODIFIED=\"1645624905125\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Tests\" />\r\n    <SUITE FILE_PATH=\"coverage/setup_py$simple_fit.coverage\" NAME=\"simple_fit Coverage Results\" MODIFIED=\"1654969215688\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Examples/Aplot\" />\r\n    <SUITE FILE_PATH=\"coverage/AdrianPack_src$csvread.coverage\" NAME=\"csvread Coverage Results\" MODIFIED=\"1645646591754\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/AdrianPack\" />\r\n    <SUITE FILE_PATH=\"coverage/setup_py$Helper.coverage\" NAME=\"Helper Coverage Results\" MODIFIED=\"1652802594338\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/AdrianPack\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 29eda08cd6491e53d62be7d02b43f697964fa529)
+++ b/.idea/workspace.xml	(date 1655203867085)
@@ -1,9 +1,8 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="ChangeListManager">
-    <list default="true" id="e9db8f2b-0092-46ad-9797-cd929e612058" name="Default Changelist" comment="Aplot.py:&#10; Added the ability to plot files and reworked the matrix plot function to utilise the same formatter.&#10; &#10;ODE.py:&#10; Fixed a bug in the new decorator that disabled the ability to use the functions without a listed argument.&#10; &#10;Since the file and plot integration is added the package is now in release 0.0.3">
+    <list default="true" id="e9db8f2b-0092-46ad-9797-cd929e612058" name="Default Changelist" comment="Fixed a bug with the decimal separator option.&#10;Added an n-sigma uncertainty boundary for linear regressions.">
       <change beforePath="$PROJECT_DIR$/AdrianPack/Aplot.py" beforeDir="false" afterPath="$PROJECT_DIR$/AdrianPack/Aplot.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/setup.py" beforeDir="false" afterPath="$PROJECT_DIR$/setup.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -32,7 +31,9 @@
     <scope name="func" pattern="" />
   </component>
   <component name="ProjectId" id="23vr99F43tyljxLA862UdUuFavm" />
-  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
+  <component name="ProjectLevelVcsManager" settingsEditedManually="true">
+    <ConfirmationsSetting value="2" id="Add" />
+  </component>
   <component name="ProjectViewState">
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showExcludedFiles" value="false" />
@@ -40,6 +41,7 @@
     <option name="showMembers" value="true" />
   </component>
   <component name="PropertiesComponent">
+    <property name="ASKED_ADD_EXTERNAL_FILES" value="true" />
     <property name="RunOnceActivity.OpenProjectViewOnStart" value="true" />
     <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />
     <property name="SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
@@ -416,7 +418,14 @@
       <option name="project" value="LOCAL" />
       <updated>1654961979488</updated>
     </task>
-    <option name="localTasksCounter" value="29" />
+    <task id="LOCAL-00029" summary="Fixed a bug with the decimal separator option.&#10;Added an n-sigma uncertainty boundary for linear regressions.">
+      <created>1654969689902</created>
+      <option name="number" value="00029" />
+      <option name="presentableId" value="LOCAL-00029" />
+      <option name="project" value="LOCAL" />
+      <updated>1654969689902</updated>
+    </task>
+    <option name="localTasksCounter" value="30" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -435,6 +444,7 @@
     <option name="oldMeFiltersMigrated" value="true" />
   </component>
   <component name="VcsManagerConfiguration">
+    <option name="ADD_EXTERNAL_FILES_SILENTLY" value="true" />
     <MESSAGE value="Updated csvread function" />
     <MESSAGE value="Updated setup.py" />
     <MESSAGE value="Added entries to the csvread docstring" />
@@ -453,7 +463,8 @@
     <MESSAGE value="Add the option &quot;show_fit&quot; to .fit() method parameters, this will now return the fit coefficients and errors in a dictionary in the order specified by either fx or from n^ith polynomial where as n^i, n^i-1, n^i-2 ... n^0." />
     <MESSAGE value="Aplot.py:" />
     <MESSAGE value="Aplot.py:&#10; Added the ability to plot files and reworked the matrix plot function to utilise the same formatter.&#10; &#10;ODE.py:&#10; Fixed a bug in the new decorator that disabled the ability to use the functions without a listed argument.&#10; &#10;Since the file and plot integration is added the package is now in release 0.0.3" />
-    <option name="LAST_COMMIT_MESSAGE" value="Aplot.py:&#10; Added the ability to plot files and reworked the matrix plot function to utilise the same formatter.&#10; &#10;ODE.py:&#10; Fixed a bug in the new decorator that disabled the ability to use the functions without a listed argument.&#10; &#10;Since the file and plot integration is added the package is now in release 0.0.3" />
+    <MESSAGE value="Fixed a bug with the decimal separator option.&#10;Added an n-sigma uncertainty boundary for linear regressions." />
+    <option name="LAST_COMMIT_MESSAGE" value="Fixed a bug with the decimal separator option.&#10;Added an n-sigma uncertainty boundary for linear regressions." />
   </component>
   <component name="com.intellij.coverage.CoverageDataManagerImpl">
     <SUITE FILE_PATH="coverage/AdrianPack_src$Aplot.coverage" NAME="Aplot Coverage Results" MODIFIED="1646608741737" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/AdrianPack" />
